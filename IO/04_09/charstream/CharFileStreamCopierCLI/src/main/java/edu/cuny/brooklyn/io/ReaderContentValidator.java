package edu.cuny.brooklyn.io;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public abstract class ReaderContentValidator {

	protected Charset charset;

	public ReaderContentValidator(Charset charset) {
		this.charset = charset;
	}

	public abstract boolean isValidChar(int c);
	public abstract boolean isFinalStateOK();

	public static ReaderContentValidator createValidator(String encoding) {
		Charset charset = Charset.forName(encoding);
		if (StandardCharsets.UTF_16.compareTo(charset) == 0 || StandardCharsets.UTF_16LE.compareTo(charset) == 0
				|| StandardCharsets.UTF_16BE.compareTo(charset) == 0) {
			return new UTF16Validator(charset);
		} else if (StandardCharsets.UTF_8.compareTo(charset) == 0) {
			return new UTF8Validator(charset);
		}
		return null;
	}
}

/* This validator is based on the question
 * "Q: Are there any byte sequences that are not generated by a UTF? How should I interpret them?"
 * in https://www.unicode.org/faq/utf_bom.html#gen4, which states,
 * "
 * in UTF-8 every byte of the form 0b110xxxxx must be followed with a byte of the form 0b10xxxxxx. 
 * " 
 * This is a simple validator, and does not consider all well-formed UTF-8 code units. For writing
 * a more thorough validator, see table 3-7 in 
 * See table 3-6 in https://www.unicode.org/versions/Unicode10.0.0/ch03.pdf#G7404
 * 
 * Convert code point to UTF-8 code units:
 * See table 3-6 in https://www.unicode.org/versions/Unicode10.0.0/ch03.pdf#G7404
 */
class UTF8Validator extends ReaderContentValidator {
	private final static Logger LOGGER = LoggerFactory.getLogger(UTF8Validator.class);
	
	private boolean expectLowerBitPattern;
	
	public UTF8Validator(Charset charset) {
		super(charset);
		if (StandardCharsets.UTF_8.compareTo(charset) != 0) {
			throw new IllegalArgumentException("Encoding " + charset + " isn't the UTF-8 encoding.");
		}
		this.expectLowerBitPattern = false;
	}

	@Override
	public boolean isValidChar(int c) {
		if (!expectLowerBitPattern && isHigherBitPattern(c)) {
			expectLowerBitPattern = true;
		} else if (!expectLowerBitPattern && isLowerBitPattern(c)) {
			LOGGER.error("Input file is misformed and cannot read correctly using encoding " + charset);
			System.err.println("Input file is misformed and cannot read correctly using encoding " + charset);			
			return false;
		} else if (expectLowerBitPattern && isLowerBitPattern(c)) {
			expectLowerBitPattern = false;
		} else if (expectLowerBitPattern && !isLowerBitPattern(c)) {
			LOGGER.error("Input file is misformed and cannot read correctly using encoding " + charset);
			System.err.println("Input file is misformed and cannot read correctly using encoding " + charset);			
			return false;
		}
		return true;
	}
	

	@Override
	public boolean isFinalStateOK() {
		return expectLowerBitPattern == false;
	}
	
	private boolean isHigherBitPattern(int c) {
		return (c & 0b11100000) == 0b11000000;
	}
	
	private boolean isLowerBitPattern(int c) {
		return (c & 0b11000000) == 0b10000000;
	}
}

/*
 * This is based on the question
 * "Q: Are there any 16-bit values that are invalid?" in 
 * https://www.unicode.org/faq/utf_bom.html, which states,
 * "
 * A: Unpaired surrogates are invalid in UTFs. These include any value in the range 
 *    D800 to DBFF not followed by a value in the range DC00 to DFFF, or any value 
 *    in the range DC00 to DFFF not preceded by a value in the range D800 to DBFF.
 * "
 * 
 * This validator cannot be reused for different readers.
 * 
 * Convert code point to UTF-16 code units:
 * See  table 3-5 in https://www.unicode.org/versions/Unicode10.0.0/ch03.pdf#G7404
 */
class UTF16Validator extends ReaderContentValidator {
	private final static Logger LOGGER = LoggerFactory.getLogger(UTF16Validator.class);
	private boolean expectLowSurrogate;

	public UTF16Validator(Charset charset) {
		super(charset);
		if (StandardCharsets.UTF_16.compareTo(charset) != 0 && StandardCharsets.UTF_16LE.compareTo(charset) != 0
				&& StandardCharsets.UTF_16BE.compareTo(charset) != 0) {
			throw new IllegalArgumentException("Encoding " + charset + " isn't one of the UTF-16 encoding.");
		} 

		this.expectLowSurrogate = false;
	}

	public boolean isValidChar(int c) {
		if (!expectLowSurrogate && Character.isHighSurrogate((char) c)) {
			expectLowSurrogate = true;
		} else if (expectLowSurrogate && Character.isLowSurrogate((char) c)) {
			expectLowSurrogate = false;
			LOGGER.debug("Read a supplementary Unicode character");
		} else if (!expectLowSurrogate && Character.isLowSurrogate((char) c)) {
			LOGGER.error("Input file is misformed and cannot read correctly using encoding " + charset);
			System.err.println("Input file is misformed and cannot read correctly using encoding " + charset);
			return false;
		} else if (expectLowSurrogate && !Character.isLowSurrogate((char) c)) {
			LOGGER.error("Input file is misformed and cannot read correctly using encoding " + charset);
			System.err.println("Input file is misformed and cannot read correctly using encoding " + charset);
			return false;
		}
		LOGGER.debug(String.format("Read U+%04X, %s", c, Character.isHighSurrogate((char) c) ? "high surrogate"
				: (Character.isLowSurrogate((char) c) ? "low surrogate" : "")));
		return true;
	}
	
	@Override
	public boolean isFinalStateOK() {
		return expectLowSurrogate == false;
	}
}
